---
layout: post
title: "python 中的列表乘法"
date: 2018-9-23 22:07:21
category: programming
tags: python
finished: true
---

python中的乘号功能很强大，除了做常规的乘法，还可以用两个乘号表示计算幂次，还是对列表和字符串使用乘号。比如：

```python
a = 'a'**5  # aaaaa
l = [1] * 10  # [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
```

这很方便，尤其是在初始化一个`n`维列表的时候我们可以`[0] * n`。

但是，这里有一个雷区。

按照上面的方式，如果初始化一个`m*n`大小的二维列表，我们可以：

```python
d = [[0] * 3] * 2  # [[0, 0, 0], [0, 0, 0]]
```

这样成功创建了一个2*3的默认值为0的二维列表。

接着改变一下第一行第一列的值：

```python
d[0][0] = 1
```

现在，`d`是`[[1, 0, 0], [0, 0, 0]]`吗？

不是。

之前因为这个问题，debug到怀疑世界。

这里要先说下这个"*"是怎么操作的，`[0] * n`是把列表中的元素复制n份，列表中的元素是0，复制0个0没问题，因为0是不可变类型。而[[0]] * n，同样对列表中的元素复制n份，列表中的元素是列表，是可变类型，所以复制的是引用，也就是说，这n个[0]是相同的！是同一个引用！

```python
d = [[0]*3] * 2
print(id(d[0]))  # 2754903898824，这是我的机器上的id值
print(id(d[1]))  # 2754903898824，和上面的一样
```

所以,
```python
d = [[0]*3] * 2
d[0][0] = 1
print(d)  # [[1, 0, 0], [1, 0, 0]]
```

所以，遇到这种情况，安全起见，还是乖乖用列表推导吧：

```python
d = [[0 for _ in range(3)] for _ in range(2)]
```

不过，列表乘法并不是一定要禁用，有些时候这种效果还是需要的。

最后，这个问题在Stackoverflow也有一个[回答][sf]说的很好。


[sf]: https://stackoverflow.com/a/2785963/4652645